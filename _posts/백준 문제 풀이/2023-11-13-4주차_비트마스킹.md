# 4주차_비트마스킹

- 19942_다이어트

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int INF=987654231;
  int n,mp,mf,ms,mv;
  int b,c,d,e,ret=INF, sum; 
  struct A{ 
  	int mp, mf, ms, mv, cost;
  }a[16]; // struct 구조를 16개 담을 수 있는 배열 선언 
   map<int, vector<vector<int>>> ret_v; // key, value <가격, 재료구성>  
  
   int main(){
   	cin >> n;
   	cin >> mp >> mf >> ms >> mv;
   	// 비트 마스킹 
   	for (int i=0; i<n; i++){
   		cin >> a[i].mp >> a[i].mf >> a[i].ms>> a[i].mv>> a[i].cost;
   }
   	for (int i=0; i< (1<<n); i++){ //2의n제곱, 모든 경우의 수에 대해 00,01,10,11 ...
  		b=c=d=e=sum=0; 
  		vector<int> v;
  		
  		for(int j=0; j<n; j++){ // 식재료 개수, 모든 재료  탐색  
  			if(i&(1<<j)){ // 식재료 고르기, 비트가 1인지 판단 //01은 1, 10은 2. 11은 {1,2} 
  				v.push_back(j+1);
  				b+=a[j].mp; 
  				c+=a[j].mf;
  				d+=a[j].ms;
  				e+=a[j].mv;
  				sum+=a[j].cost;
  				
  			}
  		}
  		if(b>=mp && c>=mf && d>=ms && e>=mv){
  			if(ret>=sum){
  				ret=sum;
  				ret_v[ret].push_back(v);
  			}
  		}
   		 	
  	}
  	
  	if(ret ==INF) cout << -1 << "\\n" ;
  	else{
  		sort(ret_v[ret].begin(), ret_v[ret].end());
  		cout << ret << "\\n"; // 최소 비용 
  		for(int a: ret_v[ret][0]){
  			cout << a <<" "; // 최소 번호  
  		}
  		
  	}
  ```

- 1285_동전 뒤집기_ 이해못함 다시 보기

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int INF=987564321;
  int n;
  char mp[20][20];
  string s;
  int a[44], ret=INF;
  // 행만 뒤집으면 열의 최적해는 정해져 있다. 
  void go(int here){
  	//행 다 뒤집고 열 조건 체크  
  	if( here ==n +1){
  		int sum=0;
  		for(int i=1; i<= (1 << (n-1)); i*=2){ //i는 1번째 H(1)H(2)T(4) 
  			int cnt=0;
  			for(int j=1; j<=n; j++) if(a[j] & i) cnt++;
  			sum += min(cnt,n-cnt); 
  		} 
  		ret =min(ret,sum);
  		return;
  	} 
  	go(here+1); // 동전 안뒤집고 
  	a[here]=~a[here]; // 뒤집고 
  	go(here +1); 
  }
  int main (){
  	cin >> n;
  	for (int i=1; i<=n; i++){
  			cin >> s;
  			int value=1;
  			for(int j=0; j<s.size(); j++){
  				if(s[j]=='T') a[i] |= value; // "T"를 기준으로  함 연산자로 비트 마스킹 , 배열 자체를 하나의 숫자로 변환  
  				value *=2;
  			
  		}
  	}
  	
  	go(1); // 1부터 시작해서  
  	cout << ret << "\\n";
  	return 0;
  }
  ```

- 17471_게리맨더링_ 너무 어려움 다시보기 dfs도 있음

- ```c++
  #include <bits/stdc++.h>
  using namespace std;
  int n, INF=987654321; // 노드 개 수  최대 10 
  int a[11], m,temp,ret=INF, comp[11], visited[11];
  vector<int> adj[11];
  
  pair<int,int> dfs(int here, int value){
  	visited[here]=1;
  	pair<int,int> ret ={1, a[here]}; // 담을 결과 값: {노드의 사이즈, 인구수의 총합} 
  	
  	
  	for (int there: adj[here]){ // 연결 노드 확인  
  		if(comp[there] != value) continue; // 내가 인자로 받은 value와 색이 달라! 
  		if(visited[there]) continue;
  		pair<int,int> _temp =dfs(there, value);
  		ret.first += _temp.first;
  		ret.second += _temp.second; // 인구수 더하 기  
  		}
  		return ret;	
  } 
  // 구역을 0과 1 두개로 나눔  
  int main (){
  	cin >> n;
  	for (int i=1; i<=n; i++){
  		cin >> a[i]; // 각 구역의 인구 수 저장 
  		
  	}
  	for(int i=1; i<=n; i++){
  		cin >> m;
  		for(int j=0; j<m; j++){
  			cin >>temp;
  			adj[i].push_back(temp);
  			adj[temp].push_back(i);
  		}
  	} 
  	
  	for (int i=1; i<(1<<n)-1;i++){ // 노드를 색칠하는 모든 경우의 수  
  		fill(comp, comp+11,0); // 노드 색칠하는 배열 초기화  
  		fill(visited, visited+11,0); //dfs 
  		int idx1=-1, idx2 =-1;
  		for(int j=0; j<n; j++){
  			if(i & (1<<j)){ // 만약 1을 만나면  
  			comp[j+1]=1; // 노드 색칠, 노드는 1부터 있으니까 +1  
  			idx1=j+1; 
  			}
  			else idx2=j+1; // 0이면 다른 나라 카운트 1 
  		} 
  		pair<int,int> comp1=dfs(idx1,1);
  		pair<int,int> comp2=dfs(idx2,0);
  		if(comp1.first + comp2.first==n) ret = min(ret, abs(comp1.second-comp2.second));
  		 // 쪼개진 구역의 합이 전체 n이 되는지, 만약 3개로 쪼개지면 <n크기를 가짐 
  	}
  	cout << (ret == INF ? -1: ret) <<"\\n";
  }
  ```