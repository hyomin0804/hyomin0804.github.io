# 2주차_DFS&BFS

- 2178_미로 탐색

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  queue<pair<int,int>> q;
  int mp[104][104];
  int visited[104][104];
  
  int dy[]={-1, 0, 1, 0};
  int dx[]={0, 1, 0, -1};
  
  int m,n,x,y,nx,ny;
  
  int main(){
  	cin >> n >> m;
  	//입력 따닥따닥은 scanf
  	for (int i=0; i<n; i++){
  		for (int j=0; j<m; j++){
  			scanf("%1d", &mp[i][j]);
  		}
  	}
  	visited[0][0]=1;
  	q.push({0,0});
  	
  	while(q.size()){
  		tie(y,x) = q.front(); q.pop();
  		
  		for (int i=0; i<4; i++){
  			ny= y + dy[i];
  			nx= x + dx[i];
  			
  			if (nx>m || ny > n || ny<0 || nx<0 ) continue;
  			if(visited[ny][nx]) continue;
  			if (mp[ny][nx]==0) continue;
  			
  			visited[ny][nx]=visited[y][x] +1;
  			q.push({ny,nx});
  		}
  		
  	}
  	
  	cout << visited[n-1][m-1] << '\\n';
  	for (int i=0; i<n; i++){
  		for (int j=0; j<m; j++){
  			cout <<visited[i][j] << " ";
  		}
  		cout << "\\n";
  	}
  	return 0;
  	
  }
  ```

- 1012_유기농 배추

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int mp[54][54], visited[54][54];
  int T,n,m,cnt,a,b,ret,ny,nx;
  int dy[]={-1, 0, 1, 0};
  int dx[]={0, 1, 0, -1};
  
  void dfs(int y, int x){
  	visited[y][x]=1;
  	
  	for (int i=0; i<4; i++){
  		ny= y + dy[i];
  		nx= x + dx[i];
  		
  		if( nx<0 || ny<0 || nx >=m || ny >= n || mp[ny][nx]==0) continue;
  		if(visited[ny][nx]) continue;
  		dfs(ny, nx);
  	}
  	
  	return;
  }
  
  int main(){
  	cin >> T;
  	while (T--){
  		//초기화 
  		fill(&mp[0][0], &mp[54][54], 0);
  		fill(&visited[0][0], &visited[54][54], 0);
  		ret=0;
  		cin >> n >> m >> cnt;
  	
  		for (int i=0; i<cnt; i++){
  			cin >> a >> b;
  			mp[a][b]=1;
  		}
  		
  		for (int i=0; i<n; i++){
  			for(int j=0; j<m; j++){
  				if(mp[i][j]==1 && visited[i][j]==0){
  					dfs(i,j);
  					ret++;
  				}
  			}
  		}
  		cout << ret << "\\n";
  
  	}
  	return 0;
  }
  ```

- 2468_안전 영역→ 다시보기?

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int mp[101][101], visited[101][101];
  int n,ny,nx;
  int dy[]={-1, 0, 1, 0};
  int dx[]={0, 1, 0, -1};
  int fin=1;
  
  void dfs(int y, int x, int depth){
  	visited[y][x]=1;
  	for(int i=0; i<4; i++){
  		ny = y + dy[i];
  		nx = x + dx[i];
  		if(nx<0 || ny<0 || nx>=n || ny >=n ) continue;
  		if (!visited[ny][nx] && mp[ny][nx]>depth) dfs(ny,nx,depth);
  		}
  	return;
  }
  
  int main(){
  	ios_base::sync_with_stdio(false);
  	cin.tie(NULL); cout.tie(NULL);
  	cin >> n;
  	for (int i=0; i<n; i++){
  		for (int j=0; j<n; j++){
  			cin >> mp[i][j];
  		}
  	}
  	
  	for (int depth=1; depth<101; depth++){
  		int ret=0;
  		fill(&visited[0][0],&visited[101][101],0);
  		for (int i=0; i<n; i++){
  			for (int j=0; j<n; j++){
  				if(mp[i][j]>depth && !visited[i][j]){
  					dfs(i,j,depth);
  					ret++;
  					cout << ret << "\\n";
  			
  				}
  			}
  		}
  		fin=max(fin, ret);
  	}
  	
  	
  	cout << fin << '\\n';
  	return 0;
  }
  ```

- 2583_영역 구하기

  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  
  int mp[101][101];
  int visited[101][101];
  int dy[]={-1, 0 , 1, 0};
  int dx[]={0, 1 , 0, -1};
  int n,m,k,a,b,c,d;
  int cnt=1;
  vector<int> ret;
  
  int dfs(int y, int x){
  	visited[y][x]=1; 
  	int cnt = 1;
  	for (int i=0; i<4; i++){
  		int ny= y + dy[i];
  		int nx= x + dx[i];
  		
  		
  		if(nx<0 || ny<0 || nx>=n || ny>=m || mp[ny][nx]==1) continue;
  		if(visited[ny][nx]) continue;
  		cnt += dfs(ny, nx);
  		
  		
  		
  	}
  	return cnt;
  }
  
  int main(){
  	cin >> m >> n >> k;
  	for (int i =0; i<k; i++){
  		cin >> a >> b >> c >> d;
  		
  		for(int x=a; x<c; x++){
  			for(int y=b; y<d; y++){
  				mp[y][x]=1;
  			}
  		}
  	}
  
  	cout << "\\n";
  	
  	for (int i=0; i<m; i++){
  		for (int j=0; j<n; j++){
  			if(mp[i][j]==0 && !visited[i][j]) {
  				cnt = 1;
  				ret.push_back(dfs(i,j));
  			}
  		}
  	}
  	sort(ret.begin(), ret.end());
  	cout<< ret.size()<<"\\n";
  	for(int i : ret) cout << i <<" ";
  	cout << "\\n";
  	
  	for (int i=0; i<m; i++){
  		for (int j=0; j<n; j++){
  			cout << visited[i][j] << " ";
  		}
  		cout << "\\n"; 
  		
  	}
  		
  
  	return 0;
  }
  ```

- 1992_쿼드 트리

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int mp[101][101];
  string s;
  int n;
  string quard(int y, int x, int size){
  	
  	if(size==1) return string(1, mp[y][x]); //char를 string으로 만들어주는 함수 , 문자열 길이 1 
  	char b= mp[y][x]; //일단 아무거나 뽑기 확인해야하니까 
  	string ret="";
  
  	for(int i=y; i<size+y; i++){
  		for(int j=x; j<size+x; j++){
  			if (mp[i][j] != b){
  				ret += "(";
  				
  				// 순서 중요!! 
  				ret += quard(y,x,size/2); //왼쪽  위 
  				ret += quard(y,x+size/2,size/2); // 오른쪽 위  
  				ret += quard(y+size/2,x,size/2); // 왼쪽 아래  
  				ret += quard(y+size/2,x+size/2,size/2);	// 오른쪽 아래
  								
  				ret += ")";
  				return ret;
  			}
  			
  		}
  	}
  	return string(1, mp[y][x]);
  	
  
  }
  
  int main(){
  	cin >> n;
  	for(int i=0; i<n;i++){
  		cin >> s;
  		for(int j=0; j<n ;j++){
  			mp[i][j] = s[j];
  		}
  	}
  	
  	cout << quard(0,0,n) << "\\n";// 시작점 x,y 배열 크기  
  	
  	return 0;
  }
  ```

- 2828_사과 담기 게임

  ```cpp
  // 내가 작성한 코드  -> 바구니 굳이 안말들어줘도 됨 l,r로만 해결 가능
  #include <bits/stdc++.h>
  using namespace std;
  
  int n,m,a,J, cnt;
  vector<int> blank; // 바구니  
  
  int main(){
  	
  	cin >> n >> m;
  	cin >> J; 
  	
  	int app[J]; //사과 배열  
  	
  	for(int i=0; i<J; i++){
  		cin >> a;
  		app[i]=a-1; // 인덱스 0으로 맞추기 위해 -1 
  	}
  	
  	for(int i=0; i<m; i++){
  		blank.push_back(i); // 바구니 설정 그림 참고  
  	}
  	
  	for( int i: app){
  		if( i <= blank.back() && i >= blank.front()){
  			//cout << "바구니 안움직임\\n"; 
  			continue;
  			
  		}else if( i > blank.back() ){
  			int a= i- blank.back();
  			//cout << "바구니 오른쪽으로 " << a << "만큼 이동\\n"; 
  			cnt+=a;
  			for( int j=0; j<m; j++ ){
  				blank[j]+= a;
  				
  				continue; 
  			}
  		}else if ( i < blank.front() ) {
  			int b= blank.front() -i ;
  			//cout << "바구니 왼쪽으로 " << b << "만큼 이동\\n";
  			cnt+=b; 
  			for( int j=0; j<m; j++ ){
  				blank[j]-= b;
  				
  				continue; 
  			}
  		}
  		
  	}
  	cout << cnt << "\\n";
  	
  	
  	
  	return 0;
  } 
  
  // 정답 코드 참고 시
  #include <bits/stdc++.h>
  using namespace std;
  int n,m,J,a,l,r,ret;
  
  int main () {
  	cin>> n >> m >> J;
  	int app[J];
  	
  	for(int i=0; i<J; i++){
  		cin >> a; 
  		app[i]=a-1;
  	}
  	
  	l= 0;
  	
  	for(int a: app){
  		r= l+m-1;
  		
  		if( a >= l && a<=r) continue;
  		else if( a > r){
  			ret+=a-r;
  			l+= a-r;
  			
  		}else if( a < l ){
  			ret+=l-a;
  			l-= l-a ;
  
  		}
  	}
  	cout << ret;
  	return 0;
  	
  }
  ```

- 2910_ 빈도 정렬

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int n,m,a;
  map<int,int> mp, mp_first;
  
  bool cmp(pair<int,int> a, pair<int,int> b){
  	if( a.first==b.first) {
  		return mp_first[a.second] <mp_first[b.second]; // 오름 차순   
  	}
  	return a.first > b.first; // 내림 차순  
  }
  
  int main (){
  	cin >> n >> m;
  	for(int i=0; i<n; i++){
  		cin >> a;
  		mp[a]++;
  		if(mp_first[a]==0) mp_first[a]=i+1; //초기화가 0으로 일어나므로 +1  
  	}
  	vector<pair<int,int>> v;
  	
  	for( auto i : mp){
  		v.push_back({i.second, i.first}); // 빈도 수, 숫자  
  	}
  	sort(v.begin(),v.end(), cmp);
  	
  	for(auto i: v){
  		for(int j=0; j<i.first; j++){
  			cout << i.second << " ";
  		}
  	}
  }
  ```